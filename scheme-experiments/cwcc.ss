; practise call/cc
(define (has-question-rec? l)
  (if (null? l)
    #f
    (if (equal? (car l) #\?)
      (or #t (has-question-rec? (cdr l)))
      (or #f (has-question-rec? (cdr l)))
      )
    )
  )

(define (has-question-ret? l)
  (call/cc 
    (lambda (return)
      (if (null? l)
        (return #f)
        (if (equal? (car l) #\?)
          (return #t)
          (return (has-question-ret? (cdr l)))
          )
        )
      )
    )
  )

(define (old-f s)
  (let* ((l (string->list s))
         (has-question? (lambda (return)
                          (if (has-question-ret? l)
                            (return #t)
                            (return #f)
                            )
                          )
                        )
         )
    (if (call/cc has-question?)
      (begin (display "no questions")(newline))
      (begin (display s)(newline))
      )
    )
  )

(define (f2 s)
  (let* ((l (string->list s))
         (has-question? (lambda (return)
                          (letrec ((has-question-helper?
                                     (lambda (l)
                                       (call/cc (lambda (local-ret)
                                                  (if (null? l)
                                                    (local-ret #f)
                                                    (if (equal? (car l) #\?)
                                                      (local-ret #t)
                                                      (local-ret (has-question-helper? (cdr l)))
                                                      )
                                                    )
                                                  )

                                                )
                                       )
                                     )
                                   )
                            (return (has-question-helper? l))
                            )
                          )
                        )
         )
    (if (call/cc has-question?)
      (begin (display "no questions")(newline))
      (begin (display s)(newline))
      )
    )
  )

(f2 "hello!")
(f2 "hello?")

(define (f . strings)
  (if (null? strings)
    '()
    (
     (display (call/cc-and-params no-questions (car strings)))(newline)
     (apply f (cdr strings))
     )
    )
  )

(define (no-questions cont s)
  (let ((l (string->list s)))
    (letrec ((is-head-question-mark? (lambda (l)
                                       (cond ((null? l) #f)
                                             ((equal? (car l) #\?) #t)
                                             (else
                                               (is-head-question-mark? (cdr l))
                                               )
                                             )
                                       )
                                     )
             )
      (cond ((is-head-question-mark? l)
             (display "no questions allowed, aborting.")(newline)
             #f
             )
            (else (cont s))
            )
      )
    )
  )

(define (call/cc-and-params f . params)
  (call/cc (lambda (cont)
             (apply f cont params))))

(f "string one!" "string two?" "should not see this")
